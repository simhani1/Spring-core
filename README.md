<div align="center">
  <h1>TIL</h1>
</div>

###  2022/12/30

#### 회원 도메인 실행과 테스트
현재 까지의 작업물은 순수 자바로 개발을 한 상태이다.

- 문제점
  - 저장소를 어떤 것을 사용할 지 아직 확정이 안된 상태이다. 따라서 MemberRepository 인터페이스의 구현체를 사용하여 값을 저장한다.<br/>하지만 그 구현체를 생성해줄 뭔가가 없기 때문에 MemberServiceImpl에서 의존관계를 갖게된다.<br/>이는 추후 저장소가 변경된다면 코드 수정이 불가피하므로 OCP, DIP에 위배되는 상황이다.

#### 주문과 할인 도메인 설계
- 주문과 할인 정책
  - 회원은 상품을 주문할 수 있다.
  - 회원 등급에 따라 할인 정책을 적용할 수 있다.
  - 할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용해달라.
  - 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루고 싶다. 최악의 경우 할인을 적용하지 않을 수도 있다.

### 2022/12/31

#### 새로운 할인 정책 개발
- discountPolicy 인터페이스의 구현체를 통해 정책 변경이 가능하다.
  - 하지만 현재 OrderServiceImpl은 추상화된 인터페이스와 구현체에 모두 의존성을 갖고 있다.
  - 따라서 할인 정책을 변경할 때 마다 코드 변경이 발생한다 -> OCP, DIP 위배

#### 해결책: 관심사 분리
- 현재 위와 같은 문제가 발생하는 원인은 OrderServiceImpl에서 SRP를 위배하고 있기 때문이다.
  - 현재 필요한 조치는 관심사를 분리시키는 작업이 필요하다.
  - 즉 OrderServiceImpl 객체는 어떤 할인 정책 구현체를 사용하는지 알 필요가 없도록 만들어야 한다.

- AppConfig 객체를 통해 외부에서 필요한 구현 객체를 주입하도록 한다.
  - 따라서 MemberServiceImpl은 인터페이스에만 의존하고 실제 구현 객체를 어떤걸 사용하는지에 대해서는 전혀 알 필요가 없어지고 외부에서 주입받는 객체를 사용하게 된다.
  - DIP가 완성된 순간이다.
  - 객체를 생성하고 연결하는 역할과 실행하는 역할이 명확히 분리되었다. -> 관심사의 분리
  - 공연 기획자라고 생각하자. 배역에 맞는 담당 배우를 선택하는 역할이다.
  - 각 배우들은 담당 기능을 '실행'하는 책임만 지면 된다.

- 새로운 구조와 할인 정책 적용
  - AppConfig의 등장으로 애플리케이션이 크게 '사용 영역'과 객체를 생성하고 '구성(Configuration)하는 영역'으로 분리되었다.
  - 할인 정책을 변경하더라도 AppConfig 내부의 구성 영역만 변경하면 된다.

#### 제어의 역전(IoC)
- 프로그램의 제어 흐름을 직접 제러하는 것이 아니라 외부에서 관리하는 것이다.

#### 의존관계 주입(DI)
- 인터페이스에 의존하도록 작성하여 실제 어떤 구현 객체가 사용될지는 모르도록 하는 것이다.
- '정적인 클래스 의존관계' & '실행 시점에 결정되는 동적인 객체 의존관계'
  - 정적인 클래스 의존관계
    - 클래스가 사용하는 import문만 보고서 의존관계를 판단할 수 있다.
    - 애플리케이션을 실행하지 않아도 분석이 가능하다.
    - 하지만 이런 의존관계 만으로는 실제로 어떤 구현 객체가 주입될 지는 알 수 없다.
  - 동적인 객체 의존관계
    - 애플리케이션 실행시점에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 의존관계가 연결되는 것을 의미한다.
    - 따라서 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
    - 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.
    - 정적인 클래스 의존관계를 변경하지 않고 === 클라이언트 코드를 수정하지 않고

#### IoC 컨테이너 & DI 컨테이너
- AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 의미
  - 의존관계 주입에 초점을 맞추어 주로 DI 컨테이너라고 부른다.
  - 어샘블러, 오브젝트 팩토리 등으로 불리기도 한다.

#### 스프링 컨테이너
- ApplicationContext를 스프링 컨테이너라고 한다.
- 기존에는 개발자가 AppConfig를 사용해서 직접 객체를 생성하고 DI를 했지만, 이제는 스프링 컨테이너를 통해 사용한다.
- Bean 어노테이션이 붙은 모든 메서드를 호출해서 객체를 등록한다.
- getBean() 메서드를 통해 등록된 객체를 가져올 수 있다.
- 지금부터는 스프링 컨테이너에 객체를 스프링 빈으로 등록하고, 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 변경되었다.

#### 스프링 컨테이너 생성
- 스프링 컨테이너 생성
  - 컨테이너를 생성하면 스프링 빈 저장소에 빈 이름, 빈 객체를 저장하게 된다.
- 스프링 빈 등록
  - Bean 어노테이션이 달려있는 메서드 명을 빈 이름, 반환되는 객체를 빈 객체로 저장하게 된다.
  - Bean 이름은 직접 부여도 가능하다. 하지만 중복되는 이름으로 설정하면 오류가 발생할 수 있으니 조심해야 한다.
- 스프링 빈 의존관계 설정 -준비-
  - 설정 정보를 작성
- 스프링 빈 의존관계 설정 -완료-
  - 컨테이너는 설정 정보를 참고해서 의존관계를 주입한다.
  - 이때 스프링은 빈을 생성하고 의존관계를 주입하는 단계가 나누어져 있다.

#### 스프링 빈 조회 - 상속관계
- 부모 타입으로 조회하면 자식 타입도 함께 조회한다.
- 따라서 최고 부모인 Object 타입으로 조회하면 모든 스프링 빈을 조회할 수 있다.

### ApplicationContext에서 빈을 조회하는 일은 거의 없겠지만 '자동 의존관계 주입'에 대해서 공부할 때 도움이 되므로 알아는 두어야 하는 지식이다.

#### BeanFactory와 ApplicationContext
![img_1.png](img/img_1.png)
- BeanFactory 
  - 스프링 컨테이너의 최상위 인터페이스
  - 스프링 빈을 관리하고 조회하는 역할을 담당한다.
  - 우리가 지금까지 사용한 대부분의 기능은 모두 BeanFactory가 제공해주는 기능들이다.
- ApplicationContext
  - BeanFactory 기능을 모두 상속받아서 제공한다.
  - 그럼 둘의 차이는 무엇인가?
    - 애플리케이션을 개발할 때는 빈 관리 및 조회 외의 많은 부가 기능이 필요하다.
    ![img_2.png](img/img_2.png)
- ApplicationContext가 제공하는 부가기능
  - 메시지 소스를 활용한 국제화 기능
  - 환경변수
    - 로컬, 개발, 운영 등을 구분해서 처리
  - 애플리케이션 이벤트
  - 편리한 리소스 조회

#### 다양한 설정 혁식 지원 - 자바 코드, XML
- 스프링 컨테이너는 다양한 형식의 설정 정보를 받아드릴 수 있게 유연하게 설계되어 있다.
  - 자바 코드, XML, Groovy 등등
- 어노테이션 기반 자바 코드 설정 사용
  - 지금까지 사용해온 내용이다.
- XML 설정 사용
  - 최근에는 스프링 부트를 사용하게 되면서 잘 사용하지 않는다.
  - 하지만 XML을 사용하면 컴파일 없이 빈 설정 정보를 변경할 수 있다는 장점도 있긴 하므로 배워두긴 해야 한다.
- XML 기반의 `appConfig.xml` 과 자바 코드로 된 `AppConfig.java`설정 정보를 비교해 보면 많이 유사하다는 것을 알 수 있다.

### 2023/1/3

#### 스프링 빈 설정 메타 정보 - BeanDefinition (나중에 다시 듣기 - 약간 어려움)
![img_1.png](img/img_3.png)
- `BeanDefinition`이라는 추상화가 존재
  - 쉽게 말해 역할과 구현을 개념적으로 나눈 것이라고 볼 수 있다.
  - 스프링 컨테이너는 자바 코드인지, XML인지 몰라도 되고 BeanDefinition만 알면 된다.
  - `BeanDefinition`을 빈 설정 메타정보라고 한다.
  - 즉 **스프링 빈은 `BeanDefinition`라는 객체로 설정 정보를 추상화 한다** 라는 것을 기억하자! 

#### 스프링 빈을 등록하는 방법 두 가지
1. 직접 등록하기
2. 팩토리 빈을 통해 등록하기(일반적인 방법)

#### 웹 애플리케이션과 싱글톤
- 스프링은 태생이 기업용 온라인 서비스 기술을 지원하기 위해 탄생하였다. 또한 대부분의 스프링 애플리케이션은 웹 애플리케이션이다.
- 따라서 고객의 요청은 계속 들어온다.
  - 그렇다면 매 번 DI 컨테이너는 Service객체를 생성해서 반환하게 된다 -> 문제가 되는 부분!
  - 이것은 메모리 낭비가 심하다. -> 싱글톤 패턴을 적용시키면 효율적으로 개선할 수 있다.
- 하지만 DI 컨테이너를 사용하면 객체를 알아서 싱글톤으로 관리해준다.
  - 이미 만들어진 객체를 공유해서 효율적으로 사용할 수 있다. 하지만 여러가지 문제점이 존재한다.
  1. 싱글톤 패턴 적용을 위한 코드 자체가 많이 들어간다.
  2. 클라이언트가 구체 클래스에 의존하므로 DIP에 위배된다. 또한 OCP 위배 가능성이 높다.
  3. 테스트하기가 어렵다.
  4. private 생성자로 자식 클래스를 만들기 어렵다.
  5. 따라서 유연성이 떨어지고 안티패턴으로 불리기도 한다.

#### 싱글톤 컨테이너
- 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.
- 스프링 컨테이너의 이런 기능으로 싱글톤 패턴의 모든 단점을 해결해준다.
- 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 `싱글톤 레지스트리`라고 한다.

#### 싱글톤 방식의 주의점
- 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체를 공유하기 때문에 상태를 유지하게 설계하면 안된다.
- 무상태로 설계해야 한다.
  - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
  - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
  - 가급적 읽기만 가능해야 한다.
  - 필드 대신, 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.

#### @Configuraion의 역할
- AppConfig 파일을 살펴보면 각 서비스 빈을 등록하는 과정에서 여러 개의 memberReposiopry 객체를 생성하는 것처럼 보인다.
- 하지만 실제 결과는 하나의 객체를 사용한다고 나온다.
```java
    @Test
    void configurationDeep() {
        ApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);
        AppConfig bean = ac.getBean(AppConfig.class);

        System.out.println("bean = " + bean.getClass());  // $$EnhancerBySpringCGLIB$$ad8aea39 가 클래스명 뒤에 추가적으로 출력된다.
    }
```
- 이 코드의 결과로는 class hello.core.AppConfig 가 출력되어야 하는데 실제로는 아래와 같은 결과가 나온다.
- `bean = class hello.core.AppConfig$$EnhancerBySpringCGLIB$$ad8aea39`
- 이것은 스프링이 `CGLIB`이라는 바이트 코드 조작 라이브러리를 사용해서 AppConfig 클래스를 상속받은 임의의 다른 클래스를 만들고, 그 클래스를 스프링 빈으로 등록한다.
![img.png](img/img_4.png)
- AppConfig@GCLIB 예상 코드
![img.png](img/img_5.png)
  - 실제로 GCLIB의 내부 기술을 사용하는 것은 매우 어렵다.
  - 또한 AppConfig@GCLIB은 APppConfig를 상속받기 때문에 조회가 가능한 것이다.
- 만약 @Configuration 어노테이션을 쓰지 않는다면 어떻게 될까?
![img.png](img/img_6.png)
  - 싱글톤이 보장되지 않는 것을 볼 수 있다.
- 따라서 고민하지 말고 스프링 설정 정보는 항상 `@Configuration`을 사용하자.

#### 컴포넌트 스캔과 의존관계 자동 주입 시작하기
- 지금까지는 스프링 빈을 등록할 때 어노테이나 XML에서 빈을 직접 등록하여 빈을 사용했다.
- 컴포넌트 스캔을 사용하려면 먼저 `@ComponentScan`을 설정 정보에 붙여주면 된다.
- 가존의 AppConfig와 다르게 @Bean으로 등록한 클래스가 아예 없다.
  - 주의 할 점은 @Configuration이 붙어있으면 해당 설정 정보도 자동으로 등록되기 때문에 앞서 만들어둔 AppConfig, TestConfig 등에서 사용한 설정 정보도 함께 등록되므로 제외시켜줘야 한다.
- @Component 어노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록해준다.
- 이전에는 @Bean으로 직접 설정 정보를 작성했고, 의존관계도 직접 명시했다. 이제는 이런 설정 정보 자체가 없기 때문에 의존관계 주입도 해당 클래스 내부에서 모두 해결해야 한다.
- 이를 @Autowired 어노테이션을 통해 설정하는 것이다.
- 컴포넌트 스캔을 통해 스프링 빈이 등록되면 클래스명에서 첫글자만 소문자로 변경된 이름으로 등록된다.
  - 만약 빈 이름을 직접 등록하고 싶으면 `@Component("지정할 이름")`으로 설정하면 된다.
- 의존관계같은 경우, 주입 받아야 하는 객체의 타입과 동일한 빈을 찾아서 주입시켜 준다.
  - 또한 생성자에 파라미터가 많더라도 알아서 찾아서 주입시켜 준다.
- 